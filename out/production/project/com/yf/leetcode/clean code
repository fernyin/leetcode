第1章 整洁代码 

第2章 有意义的命名 

第3章 函数 

3.1 短小 

3.2 只做一件事 

3.3 每个函数一个抽象层级 

3.4 switch语句=

3.5 使用描述性的名称 =

3.6 函数参数 

3.6.1 一元函数的普遍形式 

3.6.2 标识参数 

3.6.3 二元函数 

3.6.4 三元函数 

3.6.5 参数对象 

3.6.6 参数列表 

3.6.7 动词与关键字 

3.7 无副作用 

3.8 分隔指令与询问 

3.9 使用异常替代返回错误码  

3.9.1 抽离Try/Catch代码块 

3.9.2 错误处理就是一件事 

第4章 注释 
第5章 格式 
第6章 对象和数据结构 
第7章 错误处理 

7.1 使用异常而非返回码 

7.2 先写Try-Catch-Finally语句 

7.3 使用不可控异常 

7.4 给出异常发生的环境说明 

7.5 依调用者需要定义异常类 

7.6 定义常规流程 

7.7 别返回null值 

7.8 别传递null值 

第8章 边界
第9章 单元测试
第10章 类 

10.1 类的组织 

10.2 类应该短小 

10.2.1 单一权责原则 

10.2.2 内聚 

10.2.3 保持内聚性就会得到许多短小的类 

10.3 为了修改而组织 

第11章 系统 

11.1 如何建造一个城市 

11.2 将系统的构造与使用分开 

11.2.1 分解main 

11.2.2 工厂 

11.2.3 依赖注入 

11.3 扩容 

11.4 Java代理 

11.5 纯Java AOP框架 

11.6 AspectJ的方面 

11.7 测试驱动系统架构  

11.8 优化决策 

11.9 明智使用添加了可论证价值的标准 

11.10 系统需要领域特定语言 

第12章 迭进 

第13章 并发编程 

13.1 为什么要并发  

13.2 挑战 

13.3 并发防御原则 

13.3.1 单一权责原则 

13.3.2 推论:限制数据作用域 

13.3.3 推论:使用数据复本 

13.3.4 推论:线程应尽可能地独立 

13.4 了解Java库 

13.5 了解执行模型 

13.5.1 生产者-消费者模型  

13.5.2 读者-作者模型 

13.5.3 宴席哲学家 

13.6 警惕同步方法之间的依赖 

13.7 保持同步区域微小 

13.8 很难编写正确的关闭代码 

13.9 测试线程代码 

13.9.1 将伪失败看作可能的线程问题 

13.9.2 先使非线程代码可工作 

13.9.3 编写可插拔的线程代码 

13.9.4 编写可调整的线程代码 

13.9.5 运行多于处理器数量的线程

13.9.6 在不同平台上运行 

13.9.7 装置试错代码 

13.9.8 硬编码 

13.9.9 自动化 

第14章 逐步改进 
第15章 JUnit内幕 
第16章 重构SerialDate 
第17章 味道与启发 
